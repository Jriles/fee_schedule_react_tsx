/* tslint:disable */
/* eslint-disable */
/**
 * CorpFees
 * API for the Corp Fees central.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AttributeResponse
 */
export interface AttributeResponse {
    /**
     * 
     * @type {string}
     * @memberof AttributeResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AttributeResponse
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface AttributeValueResponse
 */
export interface AttributeValueResponse {
    /**
     * 
     * @type {string}
     * @memberof AttributeValueResponse
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof AttributeValueResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AttributeValueResponse
     */
    'attributeId'?: string;
}
/**
 * 
 * @export
 * @interface CreateAttributeSchema
 */
export interface CreateAttributeSchema {
    /**
     * 
     * @type {string}
     * @memberof CreateAttributeSchema
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface CreateAttributeValueSchema
 */
export interface CreateAttributeValueSchema {
    /**
     * 
     * @type {string}
     * @memberof CreateAttributeValueSchema
     */
    'title'?: string;
}
/**
 * 
 * @export
 * @interface CreateServiceAttributeValueSchema
 */
export interface CreateServiceAttributeValueSchema {
    /**
     * 
     * @type {string}
     * @memberof CreateServiceAttributeValueSchema
     */
    'attributeValueId': string;
}
/**
 * 
 * @export
 * @interface CreateServiceSchema
 */
export interface CreateServiceSchema {
    /**
     * 
     * @type {string}
     * @memberof CreateServiceSchema
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface CreateServiceVariantSchema
 */
export interface CreateServiceVariantSchema {
    /**
     * 
     * @type {string}
     * @memberof CreateServiceVariantSchema
     */
    'service_id': string;
    /**
     * 
     * @type {number}
     * @memberof CreateServiceVariantSchema
     */
    'state_cost': number;
    /**
     * 
     * @type {number}
     * @memberof CreateServiceVariantSchema
     */
    'per_page_state_cost'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateServiceVariantSchema
     */
    'service_attribute_value_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface LoginSchema
 */
export interface LoginSchema {
    /**
     * 
     * @type {string}
     * @memberof LoginSchema
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof LoginSchema
     */
    'password': string;
    /**
     * 
     * @type {boolean}
     * @memberof LoginSchema
     */
    'remember_me': boolean;
}
/**
 * 
 * @export
 * @interface ServiceAttributeLineResponse
 */
export interface ServiceAttributeLineResponse {
    /**
     * 
     * @type {string}
     * @memberof ServiceAttributeLineResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAttributeLineResponse
     */
    'attribute_title'?: string;
    /**
     * 
     * @type {Array<ServiceAttributeValue>}
     * @memberof ServiceAttributeLineResponse
     */
    'service_attribute_values': Array<ServiceAttributeValue>;
    /**
     * 
     * @type {string}
     * @memberof ServiceAttributeLineResponse
     */
    'attribute_id'?: string;
}
/**
 * 
 * @export
 * @interface ServiceAttributeValue
 */
export interface ServiceAttributeValue {
    /**
     * 
     * @type {string}
     * @memberof ServiceAttributeValue
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAttributeValue
     */
    'value_title': string;
}
/**
 * 
 * @export
 * @interface ServiceResponse
 */
export interface ServiceResponse {
    /**
     * 
     * @type {string}
     * @memberof ServiceResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceResponse
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface SuccessfulLoginResponse
 */
export interface SuccessfulLoginResponse {
    /**
     * 
     * @type {string}
     * @memberof SuccessfulLoginResponse
     */
    'session_token': string;
    /**
     * 
     * @type {string}
     * @memberof SuccessfulLoginResponse
     */
    'user_id': string;
}
/**
 * 
 * @export
 * @interface UpdateAttributeSchema
 */
export interface UpdateAttributeSchema {
    /**
     * 
     * @type {string}
     * @memberof UpdateAttributeSchema
     */
    'title'?: string;
}
/**
 * 
 * @export
 * @interface UpdateAttributeValueSchema
 */
export interface UpdateAttributeValueSchema {
    /**
     * 
     * @type {string}
     * @memberof UpdateAttributeValueSchema
     */
    'title'?: string;
}
/**
 * 
 * @export
 * @interface UpdateServiceSchema
 */
export interface UpdateServiceSchema {
    /**
     * 
     * @type {string}
     * @memberof UpdateServiceSchema
     */
    'title'?: string;
}
/**
 * 
 * @export
 * @interface VariantCreatedResponse
 */
export interface VariantCreatedResponse {
    /**
     * 
     * @type {string}
     * @memberof VariantCreatedResponse
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface VariantResponse
 */
export interface VariantResponse {
    /**
     * 
     * @type {string}
     * @memberof VariantResponse
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof VariantResponse
     */
    'state_cost': number;
    /**
     * 
     * @type {string}
     * @memberof VariantResponse
     */
    'service_id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof VariantResponse
     */
    'service_attribute_vals'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof VariantResponse
     */
    'service_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof VariantResponse
     */
    'per_page_state_cost'?: number;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a database-wide attribute. Think stock count or entity type
         * @param {CreateAttributeSchema} createAttributeSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAttribute: async (createAttributeSchema: CreateAttributeSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAttributeSchema' is not null or undefined
            assertParamExists('createAttribute', 'createAttributeSchema', createAttributeSchema)
            const localVarPath = `/attributes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionCookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAttributeSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a database-wide attribute value. Think 1000+ for stock count or Delware for jurisdiction.
         * @param {string} attributeId 
         * @param {CreateAttributeValueSchema} createAttributeValueSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAttributeValue: async (attributeId: string, createAttributeValueSchema: CreateAttributeValueSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeId' is not null or undefined
            assertParamExists('createAttributeValue', 'attributeId', attributeId)
            // verify required parameter 'createAttributeValueSchema' is not null or undefined
            assertParamExists('createAttributeValue', 'createAttributeValueSchema', createAttributeValueSchema)
            const localVarPath = `/attributes/{attributeId}/values`
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionCookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAttributeValueSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateServiceSchema} createServiceSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createService: async (createServiceSchema: CreateServiceSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createServiceSchema' is not null or undefined
            assertParamExists('createService', 'createServiceSchema', createServiceSchema)
            const localVarPath = `/services`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionCookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createServiceSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an attribute line for a service. This is how we relate attribute values to services.
         * @param {string} serviceId 
         * @param {string} attributeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServiceAttributeLine: async (serviceId: string, attributeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('createServiceAttributeLine', 'serviceId', serviceId)
            // verify required parameter 'attributeId' is not null or undefined
            assertParamExists('createServiceAttributeLine', 'attributeId', attributeId)
            const localVarPath = `/services/{serviceId}/attributes/{attributeId}/lines`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionCookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary create a new service attribute value (not an attribute value.) This only applies to the service listed in the path.
         * @param {string} lineId 
         * @param {CreateServiceAttributeValueSchema} createServiceAttributeValueSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServiceAttributeValue: async (lineId: string, createServiceAttributeValueSchema: CreateServiceAttributeValueSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lineId' is not null or undefined
            assertParamExists('createServiceAttributeValue', 'lineId', lineId)
            // verify required parameter 'createServiceAttributeValueSchema' is not null or undefined
            assertParamExists('createServiceAttributeValue', 'createServiceAttributeValueSchema', createServiceAttributeValueSchema)
            const localVarPath = `/service_attribute_lines/{lineId}/values`
                .replace(`{${"lineId"}}`, encodeURIComponent(String(lineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionCookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createServiceAttributeValueSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a variant for a service with a specific combination of Jurisdiction, Filing Speed and Entity type.
         * @param {CreateServiceVariantSchema} createServiceVariantSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVariant: async (createServiceVariantSchema: CreateServiceVariantSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createServiceVariantSchema' is not null or undefined
            assertParamExists('createVariant', 'createServiceVariantSchema', createServiceVariantSchema)
            const localVarPath = `/service_variants/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionCookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createServiceVariantSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an attribute.
         * @param {string} attributeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttribute: async (attributeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeId' is not null or undefined
            assertParamExists('deleteAttribute', 'attributeId', attributeId)
            const localVarPath = `/attributes/{attributeId}`
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionCookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an attribute value.
         * @param {string} valueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttributeValue: async (valueId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'valueId' is not null or undefined
            assertParamExists('deleteAttributeValue', 'valueId', valueId)
            const localVarPath = `/attribute_values/{valueId}`
                .replace(`{${"valueId"}}`, encodeURIComponent(String(valueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionCookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a service.
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteService: async (serviceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('deleteService', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionCookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a service attribute line.
         * @param {string} lineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceAttributeLine: async (lineId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lineId' is not null or undefined
            assertParamExists('deleteServiceAttributeLine', 'lineId', lineId)
            const localVarPath = `/service_attribute_lines/{lineId}`
                .replace(`{${"lineId"}}`, encodeURIComponent(String(lineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionCookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a service attribute value. valueId here is the service attribute value id NOT the attribute value id.
         * @param {string} valueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceAttributeValue: async (valueId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'valueId' is not null or undefined
            assertParamExists('deleteServiceAttributeValue', 'valueId', valueId)
            const localVarPath = `/service_attribute_values/{valueId}`
                .replace(`{${"valueId"}}`, encodeURIComponent(String(valueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionCookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a service variant.
         * @param {string} variantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVariant: async (variantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'variantId' is not null or undefined
            assertParamExists('deleteVariant', 'variantId', variantId)
            const localVarPath = `/service_variants/{variantId}`
                .replace(`{${"variantId"}}`, encodeURIComponent(String(variantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionCookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all a given attribute\'s possible values
         * @param {string} attributeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAttributeValues: async (attributeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeId' is not null or undefined
            assertParamExists('getAllAttributeValues', 'attributeId', attributeId)
            const localVarPath = `/attributes/{attributeId}/values`
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionCookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all database wide attributes like stock count, jurisdiction and entity type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAttributes: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/attributes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionCookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all supported services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllServices: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/services`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionCookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an attribute from its id.
         * @param {string} attributeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttribute: async (attributeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeId' is not null or undefined
            assertParamExists('getAttribute', 'attributeId', attributeId)
            const localVarPath = `/attributes/{attributeId}`
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionCookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get one service\'s details
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getService: async (serviceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('getService', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionCookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all the service attribute values for a particular service attribute line.
         * @param {string} lineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceAttrVals: async (lineId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lineId' is not null or undefined
            assertParamExists('getServiceAttrVals', 'lineId', lineId)
            const localVarPath = `/service_attribute_lines/{lineId}/values`
                .replace(`{${"lineId"}}`, encodeURIComponent(String(lineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionCookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Given a service id and an attribute id, return the service attribute line for that combination
         * @param {string} lineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceAttributeLine: async (lineId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lineId' is not null or undefined
            assertParamExists('getServiceAttributeLine', 'lineId', lineId)
            const localVarPath = `/service_attribute_lines/{lineId}`
                .replace(`{${"lineId"}}`, encodeURIComponent(String(lineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionCookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Given a service id, return the all service attribute lines.
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceAttributeLines: async (serviceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('getServiceAttributeLines', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/attribute_lines`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionCookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all variants for a particular service.
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceVariants: async (serviceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('getServiceVariants', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/variants/`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionCookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the variant (fee and other information) for a particular service variant, ie. (Amended and Restated Articles in Delaware, 1 Day). If you provide no values for the serviceAttribute Values then you will recieve a list of all service variants.
         * @param {Array<string>} [serviceAttributeValueIds] This param is an array of strings where the strings are the service attribute value ids.
         * @param {number} [pageNumber] Page number of the total variant count available. The number of variants per page currently is 50. Omitting this value is the same as asking for the first page of variants.
         * @param {number} [filingPageCount] This param represents the number of pages present in the current filing order. Some filings include a per page fee at the state level.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariants: async (serviceAttributeValueIds?: Array<string>, pageNumber?: number, filingPageCount?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/service_variants/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionCookieAuth required

            if (serviceAttributeValueIds) {
                localVarQueryParameter['serviceAttributeValueIds[]'] = serviceAttributeValueIds;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page_number'] = pageNumber;
            }

            if (filingPageCount !== undefined) {
                localVarQueryParameter['filing_page_count'] = filingPageCount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login a user using username and password.
         * @param {LoginSchema} loginSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginSchema: LoginSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginSchema' is not null or undefined
            assertParamExists('login', 'loginSchema', loginSchema)
            const localVarPath = `/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an attribute\'s name or other details. But not the attribute values.
         * @param {string} attributeId 
         * @param {UpdateAttributeSchema} updateAttributeSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttribute: async (attributeId: string, updateAttributeSchema: UpdateAttributeSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeId' is not null or undefined
            assertParamExists('updateAttribute', 'attributeId', attributeId)
            // verify required parameter 'updateAttributeSchema' is not null or undefined
            assertParamExists('updateAttribute', 'updateAttributeSchema', updateAttributeSchema)
            const localVarPath = `/attributes/{attributeId}`
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionCookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAttributeSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an attribute value.
         * @param {string} valueId 
         * @param {UpdateAttributeValueSchema} updateAttributeValueSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttributeValue: async (valueId: string, updateAttributeValueSchema: UpdateAttributeValueSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'valueId' is not null or undefined
            assertParamExists('updateAttributeValue', 'valueId', valueId)
            // verify required parameter 'updateAttributeValueSchema' is not null or undefined
            assertParamExists('updateAttributeValue', 'updateAttributeValueSchema', updateAttributeValueSchema)
            const localVarPath = `/attribute_values/{valueId}`
                .replace(`{${"valueId"}}`, encodeURIComponent(String(valueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionCookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAttributeValueSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Service values
         * @param {string} serviceId 
         * @param {UpdateServiceSchema} updateServiceSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateService: async (serviceId: string, updateServiceSchema: UpdateServiceSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('updateService', 'serviceId', serviceId)
            // verify required parameter 'updateServiceSchema' is not null or undefined
            assertParamExists('updateService', 'updateServiceSchema', updateServiceSchema)
            const localVarPath = `/services/{serviceId}/`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionCookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateServiceSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a database-wide attribute. Think stock count or entity type
         * @param {CreateAttributeSchema} createAttributeSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAttribute(createAttributeSchema: CreateAttributeSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAttribute(createAttributeSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a database-wide attribute value. Think 1000+ for stock count or Delware for jurisdiction.
         * @param {string} attributeId 
         * @param {CreateAttributeValueSchema} createAttributeValueSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAttributeValue(attributeId: string, createAttributeValueSchema: CreateAttributeValueSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAttributeValue(attributeId, createAttributeValueSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateServiceSchema} createServiceSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createService(createServiceSchema: CreateServiceSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createService(createServiceSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create an attribute line for a service. This is how we relate attribute values to services.
         * @param {string} serviceId 
         * @param {string} attributeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createServiceAttributeLine(serviceId: string, attributeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createServiceAttributeLine(serviceId, attributeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary create a new service attribute value (not an attribute value.) This only applies to the service listed in the path.
         * @param {string} lineId 
         * @param {CreateServiceAttributeValueSchema} createServiceAttributeValueSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createServiceAttributeValue(lineId: string, createServiceAttributeValueSchema: CreateServiceAttributeValueSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createServiceAttributeValue(lineId, createServiceAttributeValueSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a variant for a service with a specific combination of Jurisdiction, Filing Speed and Entity type.
         * @param {CreateServiceVariantSchema} createServiceVariantSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVariant(createServiceVariantSchema: CreateServiceVariantSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VariantCreatedResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVariant(createServiceVariantSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an attribute.
         * @param {string} attributeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAttribute(attributeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAttribute(attributeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an attribute value.
         * @param {string} valueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAttributeValue(valueId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAttributeValue(valueId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a service.
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteService(serviceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteService(serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a service attribute line.
         * @param {string} lineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteServiceAttributeLine(lineId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteServiceAttributeLine(lineId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a service attribute value. valueId here is the service attribute value id NOT the attribute value id.
         * @param {string} valueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteServiceAttributeValue(valueId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteServiceAttributeValue(valueId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a service variant.
         * @param {string} variantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVariant(variantId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVariant(variantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all a given attribute\'s possible values
         * @param {string} attributeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllAttributeValues(attributeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AttributeValueResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllAttributeValues(attributeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all database wide attributes like stock count, jurisdiction and entity type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllAttributes(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllAttributes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of all supported services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllServices(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllServices(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an attribute from its id.
         * @param {string} attributeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAttribute(attributeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttributeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAttribute(attributeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get one service\'s details
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getService(serviceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getService(serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all the service attribute values for a particular service attribute line.
         * @param {string} lineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceAttrVals(lineId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceAttrVals(lineId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Given a service id and an attribute id, return the service attribute line for that combination
         * @param {string} lineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceAttributeLine(lineId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceAttributeLineResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceAttributeLine(lineId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Given a service id, return the all service attribute lines.
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceAttributeLines(serviceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceAttributeLines(serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all variants for a particular service.
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceVariants(serviceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceVariants(serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve the variant (fee and other information) for a particular service variant, ie. (Amended and Restated Articles in Delaware, 1 Day). If you provide no values for the serviceAttribute Values then you will recieve a list of all service variants.
         * @param {Array<string>} [serviceAttributeValueIds] This param is an array of strings where the strings are the service attribute value ids.
         * @param {number} [pageNumber] Page number of the total variant count available. The number of variants per page currently is 50. Omitting this value is the same as asking for the first page of variants.
         * @param {number} [filingPageCount] This param represents the number of pages present in the current filing order. Some filings include a per page fee at the state level.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVariants(serviceAttributeValueIds?: Array<string>, pageNumber?: number, filingPageCount?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVariants(serviceAttributeValueIds, pageNumber, filingPageCount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Login a user using username and password.
         * @param {LoginSchema} loginSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginSchema: LoginSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessfulLoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an attribute\'s name or other details. But not the attribute values.
         * @param {string} attributeId 
         * @param {UpdateAttributeSchema} updateAttributeSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAttribute(attributeId: string, updateAttributeSchema: UpdateAttributeSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAttribute(attributeId, updateAttributeSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an attribute value.
         * @param {string} valueId 
         * @param {UpdateAttributeValueSchema} updateAttributeValueSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAttributeValue(valueId: string, updateAttributeValueSchema: UpdateAttributeValueSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAttributeValue(valueId, updateAttributeValueSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update Service values
         * @param {string} serviceId 
         * @param {UpdateServiceSchema} updateServiceSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateService(serviceId: string, updateServiceSchema: UpdateServiceSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateService(serviceId, updateServiceSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Create a database-wide attribute. Think stock count or entity type
         * @param {CreateAttributeSchema} createAttributeSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAttribute(createAttributeSchema: CreateAttributeSchema, options?: any): AxiosPromise<void> {
            return localVarFp.createAttribute(createAttributeSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a database-wide attribute value. Think 1000+ for stock count or Delware for jurisdiction.
         * @param {string} attributeId 
         * @param {CreateAttributeValueSchema} createAttributeValueSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAttributeValue(attributeId: string, createAttributeValueSchema: CreateAttributeValueSchema, options?: any): AxiosPromise<void> {
            return localVarFp.createAttributeValue(attributeId, createAttributeValueSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateServiceSchema} createServiceSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createService(createServiceSchema: CreateServiceSchema, options?: any): AxiosPromise<ServiceResponse> {
            return localVarFp.createService(createServiceSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an attribute line for a service. This is how we relate attribute values to services.
         * @param {string} serviceId 
         * @param {string} attributeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServiceAttributeLine(serviceId: string, attributeId: string, options?: any): AxiosPromise<void> {
            return localVarFp.createServiceAttributeLine(serviceId, attributeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary create a new service attribute value (not an attribute value.) This only applies to the service listed in the path.
         * @param {string} lineId 
         * @param {CreateServiceAttributeValueSchema} createServiceAttributeValueSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServiceAttributeValue(lineId: string, createServiceAttributeValueSchema: CreateServiceAttributeValueSchema, options?: any): AxiosPromise<void> {
            return localVarFp.createServiceAttributeValue(lineId, createServiceAttributeValueSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a variant for a service with a specific combination of Jurisdiction, Filing Speed and Entity type.
         * @param {CreateServiceVariantSchema} createServiceVariantSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVariant(createServiceVariantSchema: CreateServiceVariantSchema, options?: any): AxiosPromise<Array<VariantCreatedResponse>> {
            return localVarFp.createVariant(createServiceVariantSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an attribute.
         * @param {string} attributeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttribute(attributeId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAttribute(attributeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an attribute value.
         * @param {string} valueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttributeValue(valueId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAttributeValue(valueId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a service.
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteService(serviceId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteService(serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a service attribute line.
         * @param {string} lineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceAttributeLine(lineId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteServiceAttributeLine(lineId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a service attribute value. valueId here is the service attribute value id NOT the attribute value id.
         * @param {string} valueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceAttributeValue(valueId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteServiceAttributeValue(valueId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a service variant.
         * @param {string} variantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVariant(variantId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteVariant(variantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all a given attribute\'s possible values
         * @param {string} attributeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAttributeValues(attributeId: string, options?: any): AxiosPromise<Array<AttributeValueResponse>> {
            return localVarFp.getAllAttributeValues(attributeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all database wide attributes like stock count, jurisdiction and entity type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAttributes(options?: any): AxiosPromise<Array<object>> {
            return localVarFp.getAllAttributes(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all supported services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllServices(options?: any): AxiosPromise<Array<object>> {
            return localVarFp.getAllServices(options).then((request) => request(axios, basePath));
        },
        /**
         * Get an attribute from its id.
         * @param {string} attributeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttribute(attributeId: string, options?: any): AxiosPromise<AttributeResponse> {
            return localVarFp.getAttribute(attributeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get one service\'s details
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getService(serviceId: string, options?: any): AxiosPromise<object> {
            return localVarFp.getService(serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all the service attribute values for a particular service attribute line.
         * @param {string} lineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceAttrVals(lineId: string, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.getServiceAttrVals(lineId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Given a service id and an attribute id, return the service attribute line for that combination
         * @param {string} lineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceAttributeLine(lineId: string, options?: any): AxiosPromise<ServiceAttributeLineResponse> {
            return localVarFp.getServiceAttributeLine(lineId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Given a service id, return the all service attribute lines.
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceAttributeLines(serviceId: string, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.getServiceAttributeLines(serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all variants for a particular service.
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceVariants(serviceId: string, options?: any): AxiosPromise<object> {
            return localVarFp.getServiceVariants(serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the variant (fee and other information) for a particular service variant, ie. (Amended and Restated Articles in Delaware, 1 Day). If you provide no values for the serviceAttribute Values then you will recieve a list of all service variants.
         * @param {Array<string>} [serviceAttributeValueIds] This param is an array of strings where the strings are the service attribute value ids.
         * @param {number} [pageNumber] Page number of the total variant count available. The number of variants per page currently is 50. Omitting this value is the same as asking for the first page of variants.
         * @param {number} [filingPageCount] This param represents the number of pages present in the current filing order. Some filings include a per page fee at the state level.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariants(serviceAttributeValueIds?: Array<string>, pageNumber?: number, filingPageCount?: number, options?: any): AxiosPromise<VariantResponse> {
            return localVarFp.getVariants(serviceAttributeValueIds, pageNumber, filingPageCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login a user using username and password.
         * @param {LoginSchema} loginSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginSchema: LoginSchema, options?: any): AxiosPromise<SuccessfulLoginResponse> {
            return localVarFp.login(loginSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an attribute\'s name or other details. But not the attribute values.
         * @param {string} attributeId 
         * @param {UpdateAttributeSchema} updateAttributeSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttribute(attributeId: string, updateAttributeSchema: UpdateAttributeSchema, options?: any): AxiosPromise<void> {
            return localVarFp.updateAttribute(attributeId, updateAttributeSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an attribute value.
         * @param {string} valueId 
         * @param {UpdateAttributeValueSchema} updateAttributeValueSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttributeValue(valueId: string, updateAttributeValueSchema: UpdateAttributeValueSchema, options?: any): AxiosPromise<void> {
            return localVarFp.updateAttributeValue(valueId, updateAttributeValueSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Service values
         * @param {string} serviceId 
         * @param {UpdateServiceSchema} updateServiceSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateService(serviceId: string, updateServiceSchema: UpdateServiceSchema, options?: any): AxiosPromise<void> {
            return localVarFp.updateService(serviceId, updateServiceSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Create a database-wide attribute. Think stock count or entity type
     * @param {CreateAttributeSchema} createAttributeSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createAttribute(createAttributeSchema: CreateAttributeSchema, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createAttribute(createAttributeSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a database-wide attribute value. Think 1000+ for stock count or Delware for jurisdiction.
     * @param {string} attributeId 
     * @param {CreateAttributeValueSchema} createAttributeValueSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createAttributeValue(attributeId: string, createAttributeValueSchema: CreateAttributeValueSchema, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createAttributeValue(attributeId, createAttributeValueSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateServiceSchema} createServiceSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createService(createServiceSchema: CreateServiceSchema, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createService(createServiceSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an attribute line for a service. This is how we relate attribute values to services.
     * @param {string} serviceId 
     * @param {string} attributeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createServiceAttributeLine(serviceId: string, attributeId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createServiceAttributeLine(serviceId, attributeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary create a new service attribute value (not an attribute value.) This only applies to the service listed in the path.
     * @param {string} lineId 
     * @param {CreateServiceAttributeValueSchema} createServiceAttributeValueSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createServiceAttributeValue(lineId: string, createServiceAttributeValueSchema: CreateServiceAttributeValueSchema, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createServiceAttributeValue(lineId, createServiceAttributeValueSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a variant for a service with a specific combination of Jurisdiction, Filing Speed and Entity type.
     * @param {CreateServiceVariantSchema} createServiceVariantSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createVariant(createServiceVariantSchema: CreateServiceVariantSchema, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createVariant(createServiceVariantSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an attribute.
     * @param {string} attributeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteAttribute(attributeId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteAttribute(attributeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an attribute value.
     * @param {string} valueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteAttributeValue(valueId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteAttributeValue(valueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a service.
     * @param {string} serviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteService(serviceId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteService(serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a service attribute line.
     * @param {string} lineId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteServiceAttributeLine(lineId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteServiceAttributeLine(lineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a service attribute value. valueId here is the service attribute value id NOT the attribute value id.
     * @param {string} valueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteServiceAttributeValue(valueId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteServiceAttributeValue(valueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a service variant.
     * @param {string} variantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteVariant(variantId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteVariant(variantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all a given attribute\'s possible values
     * @param {string} attributeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAllAttributeValues(attributeId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAllAttributeValues(attributeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all database wide attributes like stock count, jurisdiction and entity type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAllAttributes(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAllAttributes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all supported services
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAllServices(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAllServices(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an attribute from its id.
     * @param {string} attributeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAttribute(attributeId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAttribute(attributeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get one service\'s details
     * @param {string} serviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getService(serviceId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getService(serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all the service attribute values for a particular service attribute line.
     * @param {string} lineId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getServiceAttrVals(lineId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getServiceAttrVals(lineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Given a service id and an attribute id, return the service attribute line for that combination
     * @param {string} lineId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getServiceAttributeLine(lineId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getServiceAttributeLine(lineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Given a service id, return the all service attribute lines.
     * @param {string} serviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getServiceAttributeLines(serviceId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getServiceAttributeLines(serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all variants for a particular service.
     * @param {string} serviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getServiceVariants(serviceId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getServiceVariants(serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the variant (fee and other information) for a particular service variant, ie. (Amended and Restated Articles in Delaware, 1 Day). If you provide no values for the serviceAttribute Values then you will recieve a list of all service variants.
     * @param {Array<string>} [serviceAttributeValueIds] This param is an array of strings where the strings are the service attribute value ids.
     * @param {number} [pageNumber] Page number of the total variant count available. The number of variants per page currently is 50. Omitting this value is the same as asking for the first page of variants.
     * @param {number} [filingPageCount] This param represents the number of pages present in the current filing order. Some filings include a per page fee at the state level.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getVariants(serviceAttributeValueIds?: Array<string>, pageNumber?: number, filingPageCount?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getVariants(serviceAttributeValueIds, pageNumber, filingPageCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login a user using username and password.
     * @param {LoginSchema} loginSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public login(loginSchema: LoginSchema, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).login(loginSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an attribute\'s name or other details. But not the attribute values.
     * @param {string} attributeId 
     * @param {UpdateAttributeSchema} updateAttributeSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateAttribute(attributeId: string, updateAttributeSchema: UpdateAttributeSchema, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateAttribute(attributeId, updateAttributeSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an attribute value.
     * @param {string} valueId 
     * @param {UpdateAttributeValueSchema} updateAttributeValueSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateAttributeValue(valueId: string, updateAttributeValueSchema: UpdateAttributeValueSchema, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateAttributeValue(valueId, updateAttributeValueSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Service values
     * @param {string} serviceId 
     * @param {UpdateServiceSchema} updateServiceSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateService(serviceId: string, updateServiceSchema: UpdateServiceSchema, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateService(serviceId, updateServiceSchema, options).then((request) => request(this.axios, this.basePath));
    }
}


