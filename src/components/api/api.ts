/* tslint:disable */
/* eslint-disable */
/**
 * CorpFees
 * API for the Corp Fees central.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AttributeResponse
 */
export interface AttributeResponse {
    /**
     * 
     * @type {string}
     * @memberof AttributeResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AttributeResponse
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface AttributeValueResponse
 */
export interface AttributeValueResponse {
    /**
     * 
     * @type {string}
     * @memberof AttributeValueResponse
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof AttributeValueResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AttributeValueResponse
     */
    'attributeId'?: string;
}
/**
 * 
 * @export
 * @interface CreateAttributeSchema
 */
export interface CreateAttributeSchema {
    /**
     * 
     * @type {string}
     * @memberof CreateAttributeSchema
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface CreateAttributeValueSchema
 */
export interface CreateAttributeValueSchema {
    /**
     * 
     * @type {string}
     * @memberof CreateAttributeValueSchema
     */
    'title'?: string;
}
/**
 * 
 * @export
 * @interface CreateServiceAttributeLineSchema
 */
export interface CreateServiceAttributeLineSchema {
    /**
     * this refers to the high-level attributes
     * @type {string}
     * @memberof CreateServiceAttributeLineSchema
     */
    'attributeId': string;
}
/**
 * 
 * @export
 * @interface CreateServiceAttributeValueSchema
 */
export interface CreateServiceAttributeValueSchema {
    /**
     * 
     * @type {string}
     * @memberof CreateServiceAttributeValueSchema
     */
    'attributeValueId': string;
}
/**
 * 
 * @export
 * @interface CreateServiceSchema
 */
export interface CreateServiceSchema {
    /**
     * 
     * @type {string}
     * @memberof CreateServiceSchema
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface CreateServiceVariantSchema
 */
export interface CreateServiceVariantSchema {
    /**
     * 
     * @type {number}
     * @memberof CreateServiceVariantSchema
     */
    'fee': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateServiceVariantSchema
     */
    'serviceAttributeValueIds': Array<string>;
}
/**
 * 
 * @export
 * @interface ServiceAttributeValueResponse
 */
export interface ServiceAttributeValueResponse {
    /**
     * 
     * @type {string}
     * @memberof ServiceAttributeValueResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAttributeValueResponse
     */
    'valueTitle': string;
}
/**
 * 
 * @export
 * @interface ServiceResponse
 */
export interface ServiceResponse {
    /**
     * 
     * @type {string}
     * @memberof ServiceResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceResponse
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface UpdateAttributeSchema
 */
export interface UpdateAttributeSchema {
    /**
     * 
     * @type {string}
     * @memberof UpdateAttributeSchema
     */
    'title'?: string;
}
/**
 * 
 * @export
 * @interface UpdateAttributeValueSchema
 */
export interface UpdateAttributeValueSchema {
    /**
     * 
     * @type {string}
     * @memberof UpdateAttributeValueSchema
     */
    'title'?: string;
}
/**
 * 
 * @export
 * @interface UpdateServiceSchema
 */
export interface UpdateServiceSchema {
    /**
     * 
     * @type {string}
     * @memberof UpdateServiceSchema
     */
    'title'?: string;
}
/**
 * 
 * @export
 * @interface VariantCreatedResponse
 */
export interface VariantCreatedResponse {
    /**
     * 
     * @type {string}
     * @memberof VariantCreatedResponse
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface VariantResponse
 */
export interface VariantResponse {
    /**
     * 
     * @type {string}
     * @memberof VariantResponse
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof VariantResponse
     */
    'fee': number;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a database-wide attribute. Think stock count or entity type
         * @param {CreateAttributeSchema} createAttributeSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAttribute: async (createAttributeSchema: CreateAttributeSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAttributeSchema' is not null or undefined
            assertParamExists('createAttribute', 'createAttributeSchema', createAttributeSchema)
            const localVarPath = `/attributes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAttributeSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a database-wide attribute value. Think 1000+ for stock count or Delware for jurisdiction.
         * @param {string} attributeId 
         * @param {CreateAttributeValueSchema} createAttributeValueSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAttributeValue: async (attributeId: string, createAttributeValueSchema: CreateAttributeValueSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeId' is not null or undefined
            assertParamExists('createAttributeValue', 'attributeId', attributeId)
            // verify required parameter 'createAttributeValueSchema' is not null or undefined
            assertParamExists('createAttributeValue', 'createAttributeValueSchema', createAttributeValueSchema)
            const localVarPath = `/attributes/{attributeId}/values`
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAttributeValueSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateServiceSchema} createServiceSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createService: async (createServiceSchema: CreateServiceSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createServiceSchema' is not null or undefined
            assertParamExists('createService', 'createServiceSchema', createServiceSchema)
            const localVarPath = `/services`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createServiceSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an attribute line for a service. This is how we relate attribute values to services.
         * @param {string} serviceId 
         * @param {CreateServiceAttributeLineSchema} createServiceAttributeLineSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServiceAttributeLine: async (serviceId: string, createServiceAttributeLineSchema: CreateServiceAttributeLineSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('createServiceAttributeLine', 'serviceId', serviceId)
            // verify required parameter 'createServiceAttributeLineSchema' is not null or undefined
            assertParamExists('createServiceAttributeLine', 'createServiceAttributeLineSchema', createServiceAttributeLineSchema)
            const localVarPath = `/services/{serviceId}/attribute_lines`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createServiceAttributeLineSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary create a new service attribute value (not an attribute value.) This only applies to the service listed in the path.
         * @param {string} serviceId 
         * @param {string} lineId 
         * @param {CreateServiceAttributeValueSchema} createServiceAttributeValueSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServiceAttributeValue: async (serviceId: string, lineId: string, createServiceAttributeValueSchema: CreateServiceAttributeValueSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('createServiceAttributeValue', 'serviceId', serviceId)
            // verify required parameter 'lineId' is not null or undefined
            assertParamExists('createServiceAttributeValue', 'lineId', lineId)
            // verify required parameter 'createServiceAttributeValueSchema' is not null or undefined
            assertParamExists('createServiceAttributeValue', 'createServiceAttributeValueSchema', createServiceAttributeValueSchema)
            const localVarPath = `/services/{serviceId}/attribute_lines/{lineId}/values`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"lineId"}}`, encodeURIComponent(String(lineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createServiceAttributeValueSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a variant for a service with a specific combination of Jurisdiction, Filing Speed and Entity type.
         * @param {string} serviceId 
         * @param {CreateServiceVariantSchema} createServiceVariantSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVariant: async (serviceId: string, createServiceVariantSchema: CreateServiceVariantSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('createVariant', 'serviceId', serviceId)
            // verify required parameter 'createServiceVariantSchema' is not null or undefined
            assertParamExists('createVariant', 'createServiceVariantSchema', createServiceVariantSchema)
            const localVarPath = `/services/{serviceId}/variants/`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createServiceVariantSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an attribute.
         * @param {string} attributeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttribute: async (attributeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeId' is not null or undefined
            assertParamExists('deleteAttribute', 'attributeId', attributeId)
            const localVarPath = `/attributes/{attributeId}`
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an attribute value.
         * @param {string} attributeId 
         * @param {string} valueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttributeValue: async (attributeId: string, valueId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeId' is not null or undefined
            assertParamExists('deleteAttributeValue', 'attributeId', attributeId)
            // verify required parameter 'valueId' is not null or undefined
            assertParamExists('deleteAttributeValue', 'valueId', valueId)
            const localVarPath = `/attributes/{attributeId}/values/{valueId}`
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)))
                .replace(`{${"valueId"}}`, encodeURIComponent(String(valueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a service.
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteService: async (serviceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('deleteService', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a service attribute line.
         * @param {string} serviceId 
         * @param {string} lineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceAttributeLine: async (serviceId: string, lineId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('deleteServiceAttributeLine', 'serviceId', serviceId)
            // verify required parameter 'lineId' is not null or undefined
            assertParamExists('deleteServiceAttributeLine', 'lineId', lineId)
            const localVarPath = `/services/{serviceId}/attribute_lines/{lineId}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"lineId"}}`, encodeURIComponent(String(lineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a service attribute value. valueId here is the service attribute value id NOT the attribute value id.
         * @param {string} serviceId 
         * @param {string} lineId 
         * @param {string} valueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceAttributeValue: async (serviceId: string, lineId: string, valueId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('deleteServiceAttributeValue', 'serviceId', serviceId)
            // verify required parameter 'lineId' is not null or undefined
            assertParamExists('deleteServiceAttributeValue', 'lineId', lineId)
            // verify required parameter 'valueId' is not null or undefined
            assertParamExists('deleteServiceAttributeValue', 'valueId', valueId)
            const localVarPath = `/services/{serviceId}/attribute_lines/{lineId}/values/{valueId}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"lineId"}}`, encodeURIComponent(String(lineId)))
                .replace(`{${"valueId"}}`, encodeURIComponent(String(valueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a service variant.
         * @param {string} serviceId 
         * @param {string} variantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVariant: async (serviceId: string, variantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('deleteVariant', 'serviceId', serviceId)
            // verify required parameter 'variantId' is not null or undefined
            assertParamExists('deleteVariant', 'variantId', variantId)
            const localVarPath = `/services/{serviceId}/variants/{variantId}`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"variantId"}}`, encodeURIComponent(String(variantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all a given attribute\'s possible values
         * @param {string} attributeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAttributeValues: async (attributeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeId' is not null or undefined
            assertParamExists('getAllAttributeValues', 'attributeId', attributeId)
            const localVarPath = `/attributes/{attributeId}/values`
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all database wide attributes like stock count, jurisdiction and entity type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAttributes: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/attributes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all supported services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllServices: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/services`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get one service\'s details
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getService: async (serviceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('getService', 'serviceId', serviceId)
            const localVarPath = `/services/{serviceId}/`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all the service attribute values for a particular service attribute line.
         * @param {string} serviceId 
         * @param {string} lineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceAttrVals: async (serviceId: string, lineId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('getServiceAttrVals', 'serviceId', serviceId)
            // verify required parameter 'lineId' is not null or undefined
            assertParamExists('getServiceAttrVals', 'lineId', lineId)
            const localVarPath = `/services/{serviceId}/attribute_lines/{lineId}/values`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"lineId"}}`, encodeURIComponent(String(lineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the fee and other information for a particular service variant, ie. (Amended and Restated Articles in Delaware, 1 Day)
         * @param {string} serviceId 
         * @param {Array<string>} serviceAttributeValueIds This param is an array of strings where the strings are the service attribute value ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariant: async (serviceId: string, serviceAttributeValueIds: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('getVariant', 'serviceId', serviceId)
            // verify required parameter 'serviceAttributeValueIds' is not null or undefined
            assertParamExists('getVariant', 'serviceAttributeValueIds', serviceAttributeValueIds)
            const localVarPath = `/services/{serviceId}/variants/`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (serviceAttributeValueIds) {
                localVarQueryParameter['serviceAttributeValueIds[]'] = serviceAttributeValueIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an attribute\'s name or other details. But not the attribute values.
         * @param {string} attributeId 
         * @param {UpdateAttributeSchema} updateAttributeSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttribute: async (attributeId: string, updateAttributeSchema: UpdateAttributeSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeId' is not null or undefined
            assertParamExists('updateAttribute', 'attributeId', attributeId)
            // verify required parameter 'updateAttributeSchema' is not null or undefined
            assertParamExists('updateAttribute', 'updateAttributeSchema', updateAttributeSchema)
            const localVarPath = `/attributes/{attributeId}`
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAttributeSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an attribute value.
         * @param {string} attributeId 
         * @param {string} valueId 
         * @param {UpdateAttributeValueSchema} updateAttributeValueSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttributeValue: async (attributeId: string, valueId: string, updateAttributeValueSchema: UpdateAttributeValueSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeId' is not null or undefined
            assertParamExists('updateAttributeValue', 'attributeId', attributeId)
            // verify required parameter 'valueId' is not null or undefined
            assertParamExists('updateAttributeValue', 'valueId', valueId)
            // verify required parameter 'updateAttributeValueSchema' is not null or undefined
            assertParamExists('updateAttributeValue', 'updateAttributeValueSchema', updateAttributeValueSchema)
            const localVarPath = `/attributes/{attributeId}/values/{valueId}`
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)))
                .replace(`{${"valueId"}}`, encodeURIComponent(String(valueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAttributeValueSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Service values
         * @param {string} serviceId 
         * @param {UpdateServiceSchema} updateServiceSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateService: async (serviceId: string, updateServiceSchema: UpdateServiceSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('updateService', 'serviceId', serviceId)
            // verify required parameter 'updateServiceSchema' is not null or undefined
            assertParamExists('updateService', 'updateServiceSchema', updateServiceSchema)
            const localVarPath = `/services/{serviceId}/`
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateServiceSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a database-wide attribute. Think stock count or entity type
         * @param {CreateAttributeSchema} createAttributeSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAttribute(createAttributeSchema: CreateAttributeSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAttribute(createAttributeSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a database-wide attribute value. Think 1000+ for stock count or Delware for jurisdiction.
         * @param {string} attributeId 
         * @param {CreateAttributeValueSchema} createAttributeValueSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAttributeValue(attributeId: string, createAttributeValueSchema: CreateAttributeValueSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAttributeValue(attributeId, createAttributeValueSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateServiceSchema} createServiceSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createService(createServiceSchema: CreateServiceSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createService(createServiceSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create an attribute line for a service. This is how we relate attribute values to services.
         * @param {string} serviceId 
         * @param {CreateServiceAttributeLineSchema} createServiceAttributeLineSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createServiceAttributeLine(serviceId: string, createServiceAttributeLineSchema: CreateServiceAttributeLineSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createServiceAttributeLine(serviceId, createServiceAttributeLineSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary create a new service attribute value (not an attribute value.) This only applies to the service listed in the path.
         * @param {string} serviceId 
         * @param {string} lineId 
         * @param {CreateServiceAttributeValueSchema} createServiceAttributeValueSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createServiceAttributeValue(serviceId: string, lineId: string, createServiceAttributeValueSchema: CreateServiceAttributeValueSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createServiceAttributeValue(serviceId, lineId, createServiceAttributeValueSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a variant for a service with a specific combination of Jurisdiction, Filing Speed and Entity type.
         * @param {string} serviceId 
         * @param {CreateServiceVariantSchema} createServiceVariantSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVariant(serviceId: string, createServiceVariantSchema: CreateServiceVariantSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VariantCreatedResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVariant(serviceId, createServiceVariantSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an attribute.
         * @param {string} attributeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAttribute(attributeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAttribute(attributeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an attribute value.
         * @param {string} attributeId 
         * @param {string} valueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAttributeValue(attributeId: string, valueId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAttributeValue(attributeId, valueId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a service.
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteService(serviceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteService(serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a service attribute line.
         * @param {string} serviceId 
         * @param {string} lineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteServiceAttributeLine(serviceId: string, lineId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteServiceAttributeLine(serviceId, lineId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a service attribute value. valueId here is the service attribute value id NOT the attribute value id.
         * @param {string} serviceId 
         * @param {string} lineId 
         * @param {string} valueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteServiceAttributeValue(serviceId: string, lineId: string, valueId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteServiceAttributeValue(serviceId, lineId, valueId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a service variant.
         * @param {string} serviceId 
         * @param {string} variantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVariant(serviceId: string, variantId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVariant(serviceId, variantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all a given attribute\'s possible values
         * @param {string} attributeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllAttributeValues(attributeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AttributeValueResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllAttributeValues(attributeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all database wide attributes like stock count, jurisdiction and entity type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllAttributes(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AttributeResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllAttributes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of all supported services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllServices(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllServices(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get one service\'s details
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getService(serviceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getService(serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all the service attribute values for a particular service attribute line.
         * @param {string} serviceId 
         * @param {string} lineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceAttrVals(serviceId: string, lineId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServiceAttributeValueResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceAttrVals(serviceId, lineId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve the fee and other information for a particular service variant, ie. (Amended and Restated Articles in Delaware, 1 Day)
         * @param {string} serviceId 
         * @param {Array<string>} serviceAttributeValueIds This param is an array of strings where the strings are the service attribute value ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVariant(serviceId: string, serviceAttributeValueIds: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariantResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVariant(serviceId, serviceAttributeValueIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an attribute\'s name or other details. But not the attribute values.
         * @param {string} attributeId 
         * @param {UpdateAttributeSchema} updateAttributeSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAttribute(attributeId: string, updateAttributeSchema: UpdateAttributeSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAttribute(attributeId, updateAttributeSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an attribute value.
         * @param {string} attributeId 
         * @param {string} valueId 
         * @param {UpdateAttributeValueSchema} updateAttributeValueSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAttributeValue(attributeId: string, valueId: string, updateAttributeValueSchema: UpdateAttributeValueSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAttributeValue(attributeId, valueId, updateAttributeValueSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update Service values
         * @param {string} serviceId 
         * @param {UpdateServiceSchema} updateServiceSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateService(serviceId: string, updateServiceSchema: UpdateServiceSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateService(serviceId, updateServiceSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Create a database-wide attribute. Think stock count or entity type
         * @param {CreateAttributeSchema} createAttributeSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAttribute(createAttributeSchema: CreateAttributeSchema, options?: any): AxiosPromise<void> {
            return localVarFp.createAttribute(createAttributeSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a database-wide attribute value. Think 1000+ for stock count or Delware for jurisdiction.
         * @param {string} attributeId 
         * @param {CreateAttributeValueSchema} createAttributeValueSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAttributeValue(attributeId: string, createAttributeValueSchema: CreateAttributeValueSchema, options?: any): AxiosPromise<void> {
            return localVarFp.createAttributeValue(attributeId, createAttributeValueSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateServiceSchema} createServiceSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createService(createServiceSchema: CreateServiceSchema, options?: any): AxiosPromise<ServiceResponse> {
            return localVarFp.createService(createServiceSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an attribute line for a service. This is how we relate attribute values to services.
         * @param {string} serviceId 
         * @param {CreateServiceAttributeLineSchema} createServiceAttributeLineSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServiceAttributeLine(serviceId: string, createServiceAttributeLineSchema: CreateServiceAttributeLineSchema, options?: any): AxiosPromise<void> {
            return localVarFp.createServiceAttributeLine(serviceId, createServiceAttributeLineSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary create a new service attribute value (not an attribute value.) This only applies to the service listed in the path.
         * @param {string} serviceId 
         * @param {string} lineId 
         * @param {CreateServiceAttributeValueSchema} createServiceAttributeValueSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServiceAttributeValue(serviceId: string, lineId: string, createServiceAttributeValueSchema: CreateServiceAttributeValueSchema, options?: any): AxiosPromise<void> {
            return localVarFp.createServiceAttributeValue(serviceId, lineId, createServiceAttributeValueSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a variant for a service with a specific combination of Jurisdiction, Filing Speed and Entity type.
         * @param {string} serviceId 
         * @param {CreateServiceVariantSchema} createServiceVariantSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVariant(serviceId: string, createServiceVariantSchema: CreateServiceVariantSchema, options?: any): AxiosPromise<Array<VariantCreatedResponse>> {
            return localVarFp.createVariant(serviceId, createServiceVariantSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an attribute.
         * @param {string} attributeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttribute(attributeId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAttribute(attributeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an attribute value.
         * @param {string} attributeId 
         * @param {string} valueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttributeValue(attributeId: string, valueId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAttributeValue(attributeId, valueId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a service.
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteService(serviceId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteService(serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a service attribute line.
         * @param {string} serviceId 
         * @param {string} lineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceAttributeLine(serviceId: string, lineId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteServiceAttributeLine(serviceId, lineId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a service attribute value. valueId here is the service attribute value id NOT the attribute value id.
         * @param {string} serviceId 
         * @param {string} lineId 
         * @param {string} valueId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceAttributeValue(serviceId: string, lineId: string, valueId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteServiceAttributeValue(serviceId, lineId, valueId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a service variant.
         * @param {string} serviceId 
         * @param {string} variantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVariant(serviceId: string, variantId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteVariant(serviceId, variantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all a given attribute\'s possible values
         * @param {string} attributeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAttributeValues(attributeId: string, options?: any): AxiosPromise<Array<AttributeValueResponse>> {
            return localVarFp.getAllAttributeValues(attributeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all database wide attributes like stock count, jurisdiction and entity type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAttributes(options?: any): AxiosPromise<Array<AttributeResponse>> {
            return localVarFp.getAllAttributes(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all supported services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllServices(options?: any): AxiosPromise<Array<object>> {
            return localVarFp.getAllServices(options).then((request) => request(axios, basePath));
        },
        /**
         * Get one service\'s details
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getService(serviceId: string, options?: any): AxiosPromise<object> {
            return localVarFp.getService(serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all the service attribute values for a particular service attribute line.
         * @param {string} serviceId 
         * @param {string} lineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceAttrVals(serviceId: string, lineId: string, options?: any): AxiosPromise<Array<ServiceAttributeValueResponse>> {
            return localVarFp.getServiceAttrVals(serviceId, lineId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the fee and other information for a particular service variant, ie. (Amended and Restated Articles in Delaware, 1 Day)
         * @param {string} serviceId 
         * @param {Array<string>} serviceAttributeValueIds This param is an array of strings where the strings are the service attribute value ids.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariant(serviceId: string, serviceAttributeValueIds: Array<string>, options?: any): AxiosPromise<VariantResponse> {
            return localVarFp.getVariant(serviceId, serviceAttributeValueIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an attribute\'s name or other details. But not the attribute values.
         * @param {string} attributeId 
         * @param {UpdateAttributeSchema} updateAttributeSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttribute(attributeId: string, updateAttributeSchema: UpdateAttributeSchema, options?: any): AxiosPromise<void> {
            return localVarFp.updateAttribute(attributeId, updateAttributeSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an attribute value.
         * @param {string} attributeId 
         * @param {string} valueId 
         * @param {UpdateAttributeValueSchema} updateAttributeValueSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttributeValue(attributeId: string, valueId: string, updateAttributeValueSchema: UpdateAttributeValueSchema, options?: any): AxiosPromise<void> {
            return localVarFp.updateAttributeValue(attributeId, valueId, updateAttributeValueSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Service values
         * @param {string} serviceId 
         * @param {UpdateServiceSchema} updateServiceSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateService(serviceId: string, updateServiceSchema: UpdateServiceSchema, options?: any): AxiosPromise<void> {
            return localVarFp.updateService(serviceId, updateServiceSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Create a database-wide attribute. Think stock count or entity type
     * @param {CreateAttributeSchema} createAttributeSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createAttribute(createAttributeSchema: CreateAttributeSchema, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createAttribute(createAttributeSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a database-wide attribute value. Think 1000+ for stock count or Delware for jurisdiction.
     * @param {string} attributeId 
     * @param {CreateAttributeValueSchema} createAttributeValueSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createAttributeValue(attributeId: string, createAttributeValueSchema: CreateAttributeValueSchema, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createAttributeValue(attributeId, createAttributeValueSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateServiceSchema} createServiceSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createService(createServiceSchema: CreateServiceSchema, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createService(createServiceSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an attribute line for a service. This is how we relate attribute values to services.
     * @param {string} serviceId 
     * @param {CreateServiceAttributeLineSchema} createServiceAttributeLineSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createServiceAttributeLine(serviceId: string, createServiceAttributeLineSchema: CreateServiceAttributeLineSchema, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createServiceAttributeLine(serviceId, createServiceAttributeLineSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary create a new service attribute value (not an attribute value.) This only applies to the service listed in the path.
     * @param {string} serviceId 
     * @param {string} lineId 
     * @param {CreateServiceAttributeValueSchema} createServiceAttributeValueSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createServiceAttributeValue(serviceId: string, lineId: string, createServiceAttributeValueSchema: CreateServiceAttributeValueSchema, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createServiceAttributeValue(serviceId, lineId, createServiceAttributeValueSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a variant for a service with a specific combination of Jurisdiction, Filing Speed and Entity type.
     * @param {string} serviceId 
     * @param {CreateServiceVariantSchema} createServiceVariantSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createVariant(serviceId: string, createServiceVariantSchema: CreateServiceVariantSchema, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createVariant(serviceId, createServiceVariantSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an attribute.
     * @param {string} attributeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteAttribute(attributeId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteAttribute(attributeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an attribute value.
     * @param {string} attributeId 
     * @param {string} valueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteAttributeValue(attributeId: string, valueId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteAttributeValue(attributeId, valueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a service.
     * @param {string} serviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteService(serviceId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteService(serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a service attribute line.
     * @param {string} serviceId 
     * @param {string} lineId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteServiceAttributeLine(serviceId: string, lineId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteServiceAttributeLine(serviceId, lineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a service attribute value. valueId here is the service attribute value id NOT the attribute value id.
     * @param {string} serviceId 
     * @param {string} lineId 
     * @param {string} valueId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteServiceAttributeValue(serviceId: string, lineId: string, valueId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteServiceAttributeValue(serviceId, lineId, valueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a service variant.
     * @param {string} serviceId 
     * @param {string} variantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteVariant(serviceId: string, variantId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteVariant(serviceId, variantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all a given attribute\'s possible values
     * @param {string} attributeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAllAttributeValues(attributeId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAllAttributeValues(attributeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all database wide attributes like stock count, jurisdiction and entity type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAllAttributes(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAllAttributes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all supported services
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAllServices(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAllServices(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get one service\'s details
     * @param {string} serviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getService(serviceId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getService(serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all the service attribute values for a particular service attribute line.
     * @param {string} serviceId 
     * @param {string} lineId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getServiceAttrVals(serviceId: string, lineId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getServiceAttrVals(serviceId, lineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the fee and other information for a particular service variant, ie. (Amended and Restated Articles in Delaware, 1 Day)
     * @param {string} serviceId 
     * @param {Array<string>} serviceAttributeValueIds This param is an array of strings where the strings are the service attribute value ids.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getVariant(serviceId: string, serviceAttributeValueIds: Array<string>, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getVariant(serviceId, serviceAttributeValueIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an attribute\'s name or other details. But not the attribute values.
     * @param {string} attributeId 
     * @param {UpdateAttributeSchema} updateAttributeSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateAttribute(attributeId: string, updateAttributeSchema: UpdateAttributeSchema, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateAttribute(attributeId, updateAttributeSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an attribute value.
     * @param {string} attributeId 
     * @param {string} valueId 
     * @param {UpdateAttributeValueSchema} updateAttributeValueSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateAttributeValue(attributeId: string, valueId: string, updateAttributeValueSchema: UpdateAttributeValueSchema, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateAttributeValue(attributeId, valueId, updateAttributeValueSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Service values
     * @param {string} serviceId 
     * @param {UpdateServiceSchema} updateServiceSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateService(serviceId: string, updateServiceSchema: UpdateServiceSchema, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateService(serviceId, updateServiceSchema, options).then((request) => request(this.axios, this.basePath));
    }
}


